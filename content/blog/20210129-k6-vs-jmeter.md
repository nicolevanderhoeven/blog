---
title: 'Comparing k6 and JMeter for load testing'
date: 2021-01-29T23:01:18+01:00
draft: false
tags: ['english', 'text', 'video', 'jmeter', 'k6.io']
---

{{< rawhtml >}}
<link rel="canonical" href="https://k6.io/blog/k6-vs-jmeter">
{{< /rawhtml >}}

_Originally posted on [k6.io](https://k6.io/blog/k6-vs-jmeter)._

{{< youtube noZppBruOSY >}}

# Introduction

When I [joined the k6 team in late November](https://www.youtube.com/watch?v=zcYeboT5FYE&list=PLJdv3RhAQXNHsC8OOV3ZjwZvC9tRoAYF2), the foremost question on my mind was "How does this compare to JMeter?" You see, I come from a performance testing consulting background, and in the last few years, JMeter has been far and away my tool of choice.

So what am I doing on the k6 site, talking about how much I love JMeter? Well, firstly, it turns out that the k6 team is pretty open and transparent, especially about potential improvements in k6. Secondly, I want to share my reasons for wanting to explore k6 as a load testing tool-- the same reasons that ultimately convinced me to join the team that builds it.

## What is JMeter?

[JMeter](https://jmeter.apache.org/) is an open source load testing tool built entirely in Java by the [Apache Foundation](https://www.apache.org/). It was first released in 1998, and it made waves because of its audacity in taking on more popular but proprietary load testing tools. JMeter took what other companies were charging a lot of money for and published it online for everyone to use-- for free. Although scripts can also be extended using code, majority of the scripting in JMeter is done using the UI. At the time of this writing, the latest version of JMeter is 5.4.

## What is k6?

k6 is an [open source](https://github.com/loadimpact/k6) load testing tool released by [LoadImpact](https://loadimpact.com) in 2017. LoadImpact had previously consisted of the SaaS platform (now [k6 Cloud](https://k6.io/cloud)) and professional services. k6 is written in Go, but scripts are written in Javascript. Taking the opposite tack to JMeter, k6's main selling point is its code-based scripting and heavy prioritization of the developer experience. The latest version of k6 is 0.30.

## Which is better?

This article isn't about which tool is _better_, because as much as we might prefer a clear-cut answer, there's no "best tool". Everything depends on the situation your team is in: what, how, why, and when you're testing.

The question that I want to answer here is: _What situations does each tool excel in?_

<hr />

# When does JMeter excel?

## When you want to get started quickly

### JMeter has a GUI

Many testing teams make decisions on load testing tools based on this fact alone. Sometimes, if you're in a situation where people haven't done load testing before and need to learn a new tool, a GUI-driven tool like JMeter is simply the most frictionless option. A tool with a GUI will be less daunting for many testers that are used to the mostly no-code UIs of the likes of Postman or SOAPUI.

![JMeter's starting screen: a fresh new test plan](/blog/assets/01-jmetergui.png)

I've always thought of JMeter as user-friendly, but a developer friend recently pointed out that the Test Plan screen that greets you when you first start JMeter doesn't provide any indication of how to create an HTTP sampler. None of the icons add elements to the test plan. It takes a bit of exploring to realize that right clicking on the test plan, or going to Edit > Add, will show the "Add" menu that you need. He has a point there: UI is subjective to a certain degree. However, I'd argue that it's definitely easier for non-developers to explore a UI than a bit of code.

k6 doesn't have a GUI packaged within the tool, but the [k6 Test Builder](https://k6.io/docs/test-authoring/test-builder) is available for free. It's a way to create tests with a GUI interface, and despite its inclusion in k6 cloud, it doesn't require any subscription to use. However, it isn't as fully-featured as JMeter.

### JMeter supports many protocols and features out of the box

Here's [the official list](https://jmeter.apache.org/index.html) of the protocols that JMeter supports:

- Web - HTTP, HTTPS (Java, NodeJS, PHP, ASP.NET, …)
- SOAP / REST Webservices
- FTP
- Database via JDBC
- LDAP
- Message-oriented middleware (MOM) via JMS
- Mail - SMTP(S), POP3(S) and IMAP(S)
- Native commands or shell scripts
- TCP
- Java Objects

In contrast, k6 supports the following protocols:

- Web - HTTP/1.1, [HTTP/2](https://k6.io/docs/using-k6/protocols/http-2) (Java, NodeJS, PHP, ASP.NET, …)
- [WebSockets](https://k6.io/docs/using-k6/protocols/websockets)
- [gRPC](https://k6.io/docs/using-k6/protocols/grpc)
- SOAP / REST Webservices

The protocols above are those that are natively supported. However, both tools allow the development of third-party plugins, adding support for more protocols. The number of [k6 community extensions](https://github.com/topics/xk6), through [xk6](https://k6.io/blog/extending-k6-with-xk6), is growing, but [JMeter plugins](https://jmeter-plugins.org/) still outnumber them. In many cases, the protocols your application uses may make the decision for you of which tool to use.

JMeter also has most of the features you'll need for a basic load test, and you don't have to code any of it up yourself. Its parent-child element structure means that you can modify a specific element, like an HTTP request, or modify all HTTP requests, with equal ease. Adding think time to all requests is as easy as adding a Uniform Random Timer to your thread group, and all requests within that group will inherit it.
With code-based load testing tools, it can be a bit more difficult to find out what's possible without a UI. Some of the gap, however, can be bridged by an IDE with good autocompletion.

## When you want a mature community with tons of documentation

JMeter's old, and sometimes that's a good thing. It's been around since 1998, so at this point, it's had 22 years to improve and to build a following. JMeter has a presence on nearly every community networking site, and no matter how specific your use case for JMeter is, the chances are that it's been done before. Searching "how to load test X with JMeter" is bound to yield thousands of hits and some videos showing you exactly how to do it.

JMeter's [Component Reference](https://jmeter.apache.org/usermanual/component_reference.html) is proof of JMeter's extensive and thorough documentation. Every element, function, and property is discussed in more detail than most people could ever want, and that's just the "official" documentation that's on the Apache site. There are thousands of JMeter books, tutorials, and courses by its passionate users.

The [JMeter GitHub repository](https://github.com/apache/jmeter) has 17,290 commits as of December 2020 - evidence of a community of developers that have committed some time and experience to JMeter over the last two decades.

In comparison, the k6 community is growing, but still small. There is an official and [central community forum](https://community.k6.io/) that allows users to share their experiences with k6, which is something missing from the JMeter community. The [k6 repository](https://github.com/loadimpact/k6) does have more stars, but significantly fewer commits at 3,795. Much of the disparity, of course, is because k6 is very new - the open-source tool k6 was only released in 2017.

## When you need a cost-effective way to do distributed load testing

One of JMeter's absolute best features is that it gives you a framework for running distributed load tests with it. This is pretty special for a free and open-source tool.

Distributed testing means ramping up the amount of load you're generating with your load tests, usually by increasing the number of virtual users and running multiple instances of your script on other load generators. JMeter accomplishes this by designating a controller node and letting you set up worker nodes. Each worker node needs to have a copy of `jmeter-server`, a utility included with every JMeter installation (in `jmeter/bin`).

![JMeter comes with a native distributed testing mode](/blog/assets/02-jmeterdistributed.svg)

Source: [Apache JMeter](https://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.html)

These worker nodes then run copies of your test plan and exert load against your application server. You can use on-premise or cloud machines as your worker nodes. A distributed execution like this takes a bit to set up, but it does work surprisingly well.

k6 doesn't have a _native_ distributed load testing mode. You _can_ containerize it yourself and deploy it via Kubernetes, for instance, but it does require a more involved setup. The team is also working on the [k6 Operator](https://github.com/k6io/operator), which makes setup significantly easier, but it is experimental and comes with drawbacks such as not supporting threshold synchronization between instances. For now, the easiest way to scale up on k6 is by using the paid service k6 Cloud, which reduces setup time and complexity significantly.

It's important to note that JMeter can be quite resource-hungry, and thus is more likely to require multiple load generators to generate load than k6. Depending on the resources of the load generator, JMeter can run about a thousand virtual users on average, and scaling up your test beyond that point will require a distributed execution setup. A single instance of k6, on the other hand, can run tens of thousands of virtual users given the same resources. More on that later.

## When you want canned reports built into your load testing tool

JMeter's many listeners allow you to decide exactly what format you want to view results in. Debugging? Use the View Results Tree. Wanting metrics for your load test? Use the Summary or Aggregate Report.

![Adding listeners like View Results Tree in JMeter lets you visualize results in different ways](/blog/assets/03-jmeterlistener.png)

In addition, JMeter can generate HTML reports based on your load tests. They're currently quite limited, but functional, and they have several default graphs to help you analyze your load test. They are not interactive, but they are pretty easy to generate and a good starting point for putting together a report template for your tests.

![JMeter's built-in HTML dashboard is limited but functional](/blog/assets/04-jmeterhtmlreport.png)

k6 does not have built-in reporting. Its modular nature lends itself better to integrating with [many other data analytics tools](https://k6.io/docs/results-visualization), including Grafana, Datadog, New Relic, Amazon CloudWatch, and k6 Cloud-- all of which are better analysis tools and can provide more insights than what JMeter's reports can provide, but they do require you to set up another tool to analyze your tests. If you're running low on time and can make do with its reports, JMeter does really well at providing that extra value out of the box.

# When does k6 excel?

## When you want to get started quickly

Yup, I put this one in both the JMeter and k6 sections. JMeter and k6 can each be easy to get started with, but for very different reasons.

### Installation

k6 installs extremely quickly - on my first installation of it on macOS, it took [7 seconds](https://www.youtube.com/watch?v=y5tteMKZUqk&t=99) via `brew install k6`. It doesn't require nodeJS or any other dependencies, either.

JMeter itself is fairly easy to install, but before you install JMeter, you need to install Java. Especially if you're using Windows, it's a bit of a rite of passage for a new JMeter user to run into issues adding the environment variables needed for Java to function.

It can also be confusing to determine which version of Java is the right one. There's JDK, JRE, and recently Oracle has added to the confusion by announcing that some versions of Java (but not all) are going to require a license. 

![Oracle's changing Java licensing can cause confusion for JMeter users](/blog/assets/05-javalicense.png)

Source: [Oracle Java](https://java.com/en/download/)

While JMeter is still free via OpenJDK, I've spoken to a few testers who mistakenly thought they'd have to pay for JMeter. It's a little disconcerting to see Oracle flexing its muscles here, especially if you've built a whole performance testing suite on Java through JMeter.

### Plugins

k6 [supports plugins](https://k6.io/blog/extending-k6-with-xk6), but they're not necessary. For most use cases, k6's built-in functionality should be more than sufficient. This is in sharp contrast to JMeter, where everything is a plugin ... even the [Plugin Manager](https://jmeter-plugins.org/wiki/PluginsManager/)!

Most JMeter users would argue that there is a standard set of plugins that you should download before you even begin to use it. A new JMeter user might not necessarily know where to find these and may have a less-than-satisfying experience out of the box.

Here are a few things you _won't_ have if you stick to a vanilla, no-plugin JMeter installation:

- Thread groups: No custom load profile, stages, rendezvous
- Controllers: No parallel controller to execute requests in parallel
- Samplers: No HTTP/2 support
- Test Data: No randomization of lines within a CSV file (sequential only)
- Timers: No throughput shaping timer for setting throughput in stages

These functions are all available within k6 from the get-go.

### Scripting

k6 scripts are written in javascript, making them simple to write and run. All you need is one installer (on Microsoft Windows) or a single command on your terminal and any text editor. For JMeter, you'll need to install a few things locally before you can get started: Java, JMeter itself, and the standard set of plugins you'll need. This can be confusing for new users. Who hasn't struggled with environment variables at some point when learning to use JMeter, especially on Windows?

It also takes time to learn any new UI, whereas javascript is near-ubiquitous and it's a good language to learn when you're load testing web sites anyway.

## When you want to maximize performance and efficiency

### Test your test tools!

Why does all this matter?

When we're talking about simulating many virtual users, slow performance = high cost. There is a cost to the number of load generators you use, whether it's the cost to acquire and maintain them (on-prem) or the cost of a cloud service.

It makes sense to consider the performance limitations of your load testing tool before you use it to improve your own application's performance.

### k6 builds on Go's stellar performance

k6 is written in Go, and Go is built with performance in mind. "Go is a compiled language and does not need to be interpreted, unlike Java or Python. There is no added layer of complexity." It also has no external dependencies, which is a good thing. Fewer moving parts for a performance tester means fewer potential sources of a bottleneck.

The simplest and most common way for a load testing tool to run a virtual user is to assign one virtual user to one kernel or OS thread. However, the 1 Thread: 1 Virtual User paradigm has a serious flaw: when a virtual user is waiting for a response or executing a programmed `sleep()`, the thread is also blocked, and cannot process other work.

In k6, each virtual user is run on a goroutine, not a thread. What difference does that make? Well, goroutines can be controlled by something called the Go Scheduler, which acts like a traffic cop. It reuses idle threads and intelligently assigns work, by allowing "work stealing" and work hand-offs between threads. Does this sound familiar? This is the same principle that load balancers are built on: An external monitor that oversees the flow of work improves general performance. Go itself is intrinsically load-balanced in a way that many programming languages aren't, which makes it the perfect foundation for a load testing tool.

Being able to leverage Go's innate performance optimizations also translates into significantly less memory utilization. One thread running k6 doesn't go above 100 kb, whereas a JVM thread like JMeter uses, for instance, [uses the default of 1MB](https://www.baeldung.com/jvm-configure-stack-sizes). That's 1000% more than k6! Of course, Java allows a user to tweak an app's memory utilization, so the difference is usually not quite as stark, but it's still interesting to note that Go has a much lower starting point.

> ... creating [a] new thread in Java is not memory efficient. As every thread consumes approx 1MB of the memory heap size and eventually if you start spinning thousands of threads, they will put tremendous pressure on the heap and will cause shut down due to out of memory. Also, if you want to communicate between two or more threads, it’s very difficult. - [Keval Patel](https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65)

### Performance benefits in practice

**Fewer load generators needed**

k6's comparatively better performance means it needs fewer load generators to execute a given amount of load. Rafaela Azevedo made a comparison of the memory used by k6 and JMeter, and [here are her results](https://azevedorafaela.com/2020/07/06/load-tests-jmeter-vs-k6/):

JMeter took up 760 MB of memory.

![In an independent test by Rafaela Azevedo, JMeter took up 760 MB of memory](/blog/assets/06-jmeterbenchmark.png)

Source: [Rafaela Azevedo](https://azevedorafaela.com/2020/07/06/load-tests-jmeter-vs-k6/)

Meanwhile, k6 took up 256 MB of memory.

![In an independent test by Rafaela Azevedo, k6 took up 256 MB of memory compared to JMeter's 760 MB for the same test](/blog/assets/07-k6benchmark.png)

Source: [Rafaela Azevedo](https://azevedorafaela.com/2020/07/06/load-tests-jmeter-vs-k6/)

Rafaela's findings are further affirmed by our own benchmarks.

![A comparison of maximum throughput and memory for the most popular open-source load testing tools](/blog/assets/08-internalbenchmarks.png)

Source: Ragnar Lönn, in our [Load Testing Tool Comparison](https://k6.io/blog/comparing-best-open-source-load-testing-tools)

k6's lower memory footprint is the reason it can run more virtual users and generate more load than average. Whether you're using load generators that are on-premise or in a cloud, you'll pay less for provisioning costs when using k6. This cost saving makes k6 a great tool for budget-conscious teams.

> The common misconception of many load testers is that distributed execution (ability to launch a load test on multiple machines) is required to generate large load. This is not the case with k6. - [Rafaela Azevedo](https://azevedorafaela.com/2020/07/06/load-tests-jmeter-vs-k6/)

k6 is different from many other load testing tools in the way it handles hardware resources. A single k6 process will efficiently use all CPU cores on a load generator machine. A single instance of k6 is often enough to generate load of 30.000-40.000 simultaneous users (VUs). This amount of VUs can generate upwards of 300,000 requests per second (RPS).

> Unless you need more than 100,000-300,000 requests per second (6-12M requests per minute), a single instance of k6 will likely be sufficient for your needs. - [k6 documentation](https://k6.io/docs/testing-guides/running-large-tests)

**No out of memory errors**

k6 is also good for when you're short on time. Using JMeter means getting familiar with how to performance tune Java and how to fix the [most common Java performance problems](https://www.eginnovations.com/blog/top-10-java-performance-problems/), because there are several. The one that I've personally run into the most while using JMeter is:

```bash
ERROR - jmeter.threads.JMeterThread: Test failed! java.lang.OutOfMemoryError: 
Java heap space. 
```

You're not really a JMeter load tester until you've seen this error. :)

The cause for this error is usually that there was an insufficient amount of Heap memory allocated to JMeter. Yup-- in addition to monitoring your load generator's memory usage, you'll also need to monitor the JVM's memory usage. You can set the amount of heap memory allocated to JMeter by modifying the JMeter binary itself and changing this line:

```java
# This is the base heap size -- you may increase or decrease it to fit your
# system's memory availability:
: "${HEAP:="-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m"}"
```

Even JMeter official documentation suggests that you increase the Java Heap size beyond 1GB before you even run your first load test.

> Increase the Java Heap size. By default JMeter runs with a heap of 1 GB, this might not be enough for your test and depends on your test plan and number of threads you want to run - [Apache JMeter](https://jmeter.apache.org/usermanual/get-started.html)

**No GUI means no resource overhead during load tests**

GUIs typically add significantly more overhead to an application, which is one of the reasons why k6 doesn't have one.

When you're running a load test, the best practice is to run it from the command line anyway-- because otherwise, it interferes with your results. Code-based load testing tools are performant from the beginning.

JMeter is peppered with warnings about the GUI's effect on performance. Here's one from the "JMeter documentation:

> Don't run load test using GUI mode ! - [Apache JMeter](https://jmeter.apache.org/usermanual/get-started.html)

And here's a message that occurs upon startup of JMeter:

![JMeter's startup screen warns users not to use the GUI mode for load testing](/blog/assets/09-jmeterguimodewarning.png)

Not having a GUI means there's one less gotcha. Any load testing scripts you create in k6 are ready for prime-time execution whenever you're ready.

## When you want to do goal-oriented testing

The most important question a load tester can ask when starting a new load testing project is "Why"?
Test plans should be made to directly address a team's reasons for wanting to do load testing, and that should be reflected in the non-functional requirements. Non-functional requirements, in turn, should then give some guidance as to the bounds of acceptable performance. A common example for these bounds, or thresholds, is an average response time of less than 3 seconds for all transactions during the test.
k6 does this natively with [global thresholds](https://k6.io/docs/using-k6/thresholds) worked into the script, and you can also create your own metric to use in a threshold:

```javascript
import http from 'k6/http';
import { Rate } from 'k6/metrics';

const myFailRate = new Rate('failed requests');

export let options = {
  thresholds: {
    'failed requests': ['rate<0.1'], // threshold on a custom metric
    http_req_duration: ['p(95)<500'], // threshold on a standard metric
  },
};

export default function () {
  let res = http.get('https://test-api.k6.io/public/crocodiles/1/');
  myFailRate.add(res.status !== 200);
}

```

Source: [k6 documentation](https://k6.io/docs/using-k6/thresholds)

JMeter doesn't natively support thresholds at the test-level. There are a few ways that I've been able to work around this:

- **Duration Assertion**: You can add a Duration Assertion to any sampler in JMeter, which allows you set an acceptable response time for that request in milliseconds, beyond which the request (and the transaction that encompasses it) would be marked as failed. However, this is still just at the individual request level, and even putting the duration assertion element at the Test Plan level only applies the same threshold to each child request. It doesn't constitute pass/fail criteria for the test as a whole.

- **Timers**: For criteria related to throughput, you can use the Constant Throughput Timer or the Throughput Shaping Timer (plugin). This approach controls how many requests per second are spent. In my experience, it's worth testing how these timers behave when using nested transaction controllers - it may take some rearranging to get right.

- **Performance Plugin**: When integrating JMeter with Jenkins, you can use the Performance Plugin to set error thresholds and mark test runs ("builds") as unstable or failed within Jenkins.

- **Custom Code**: You can use the JSR223 Sampler to write a bit of Groovy or BeanShell code that collects and parses response metrics.

The problem is that even though these options make setting thresholds possible in JMeter, they're still workarounds that don't come with JMeter out of the box or don't adequately address the creation of different types of thresholds (error, response time, throughput, CPU, memory). What I end up doing, more often than not, is exporting the raw data from JMeter and doing the analysis myself using another tool.

## When you're part of a team of scripters

k6 shines in situations where more than one person could be doing the scripting.

### It strikes a middle ground that developers and testers can compromise on

Software quality should not be the sole responsibility of testers; quality should be baked into every activity when building software. One of the challenges in implementing this concept, however, is that there has traditionally been a segmentation in tools and languages used by team members with different functions. Developers use one tool; testers use another. It's difficult to encourage developers to test and testers to code in this environment, and many testing tools only further encourage this divide. A developer can't use a tool like JMeter for anything but testing, so the incentive to invest the effort in learning it is lower.

k6 bridges the gap by bringing testing concepts and features to an environment and language that developers are already spending their time in. Javascript is useful for more than just writing load testing scripts, and k6 works well with any IDE or text editor. A frictionless developer experience is central to the k6 philosophy.

### It's easier to collaborate on scripts

Once you've convinced both devs and testers to contribute to load testing scripts, how do you keep track of changes? How do you manage scripts that multiple people are working on at the same time?
With tests as code, the easiest way is to just use versioning tools like Git, the way you probably are already using for your application code. Again, no new framework or processes to learn here.
k6's conciseness and portability really proves to be an advantage in collaboration situations. To illustrate this, let's consider a simple test script that contains a few things:

- A GET request to [our test site](https://test.k6.io), `https://test.k6.io`
- A transaction that calls this request `01_Home`
- A check to fail non-HTTP 200 responses or responses that don't have the text `Collection of simple web-pages suitable for load testing`
- Variable think time
- We'll just run that as a single user, for a single iteration. Here's what that script looks like in k6:

```javascript
import http from 'k6/http';
import { sleep, check } from 'k6';

export default function () {
    let res = http.get('https://test.k6.io', {tags: { name: '01_Home' }});
    check(res, {
      'is status 200': (r) => r.status === 200,
      'text verification': (r) => r.body.includes("Collection of simple web-pages suitable for load testing")
    });
    sleep(Math.random() * 5);
}
```

You can track JMeter scripts on Git, too. Here's what the same script looks like in JMeter:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
      </ThreadGroup>
      <hashTree>
        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="01_Home" enabled="true">
          <boolProp name="TransactionController.includeTimers">false</boolProp>
          <boolProp name="TransactionController.parent">true</boolProp>
        </TransactionController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request" enabled="true">
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
            <stringProp name="HTTPSampler.domain">test.k6.io</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path"></stringProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="-745788246">Collection of simple web-pages suitable for load testing</stringProp>
              </collectionProp>
              <stringProp name="Assertion.custom_message"></stringProp>
              <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
              <boolProp name="Assertion.assume_success">false</boolProp>
              <intProp name="Assertion.test_type">16</intProp>
            </ResponseAssertion>
            <hashTree/>
          </hashTree>
        </hashTree>
        <UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Uniform Random Timer" enabled="true">
          <stringProp name="ConstantTimer.delay">1000</stringProp>
          <stringProp name="RandomTimer.range">4000</stringProp>
        </UniformRandomTimer>
        <hashTree/>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>

```

Which one is easier to understand? If you had to modify the script to add a request, which format would you choose to do it in?

Scripting in XML makes merge conflicts more likely and breaking changes in automation pipelines way more difficult to pinpoint.

I've collaborated with others on JMeter scripts in the past, and we always opened up scripts in the GUI. It's way easier to spot changes there - but that also created some new issues.

## When you want something easy to maintain

### Versioning for load testing

When ramping up load tests to more than one load generator, keeping track of the versions of necessary components ensures that one load generator's traffic is the same as another's. The value of reducing variables in scientific experiments holds true for load testing.

With k6, you just need to worry about the version of k6 and the script. No other dependencies are required. If you're using plugins, you'd need to track those too, but as mentioned previously, plugins in k6 aren't as necessary as they are in some other tools -- and k6 is available as a Docker image to reduce those issues.

With something like JMeter, there are more levels to consider. There's the version of JMeter itself, Java, versions of plugins, and then the script. Every new layer introduces more changes for incompatibilities. In previous projets I've worked on, someone would inevitably try out a new plugin and forget to discuss it with the team, and anyone who tried to open that script in their copy of JMeter would see this error:

![This is the error that JMeter throws when you attempt to open a test plan that includes a plugin you don't have installed locally](/blog/assets/10-jmeterpluginerror.png)

The error means there's a plugin that the script uses that JMeter doesn't recognize, but depending on the plugin, it's not always this easy to pinpoint which one (it was the `Ultimate Thread Group` in this case).
You don't want that happening in the middle of your load test because you forgot to add a plugin to some of your load generators!

### It's easier to link test code with application code

If your application code is in Javascript, k6 is a shoo-in as a load testing tool. You could build tests that are tightly integrated with application code by importing objects and having your tests interacting with them directly. This approach would reduce a lot of time spent in refactoring test scripts when objects are changed.

If you're already using VS Code, k6 even has a [VS Code plugin](https://marketplace.visualstudio.com/items?itemName=k6.k6).

### Test as code gives you control

Having your scripts be pure code reduces ambiguities in that you're not limited by poor UI design or bugs in third-party plugins. k6 scripts are Typescript-typed, so most IDEs support autocompletion while you're scripting - the code equivalent of helpful tooltips, except way more universal.
k6 scripts give you the freedom to import and use JS libraries, so you can build on code others have already written. While k6 is not NodeJS, there are even [some NodeJS packages](https://k6.io/docs/using-k6/modules#bundling-node-modules) that you can bundle for use with your scripts.

### No external dependencies

k6 doesn't require NodeJS or anything else to run, which also reduces the likelihood of bugs that might affect your scripts. For example, since JMeter runs on Java, it is also dependent on Java. When Java receives a new version, that often requires a JMeter update as well. JMeter versions understandably lag a bit behind Java versions as developers refactor code, but this gap can lead to potential security issues in a previous version of Java that may remain unpatched in the meantime.

With k6, development can proceed independently of any third-party component, so major issues can be addressed more easily.

# Comparison table: JMeter vs k6

| **Feature** | **JMeter**  | **k6**      | 
| ----------- | ----------- | ----------- |
| **Written in** | Java | Go |
| **Scripting language** | Limited: some Java (Groovy, Beanshell, etc) | Javascript |
| **Protocols** | Supports most protocols via plugins (native support for HTTP/1.1, SOAP, FTP, JDBC, LDAP, MOM via JMS, SMTP, POP3, IMAP, shell scripts, TCP, Java objects) | Supports fewer, modern protocols natively (HTTP/1.1, HTTP/2, WebSockets, gRPC)|
| **External dependencies** | Java | none |
| **Resource utilization** | [Poor](https://k6.io/blog/static/b4075246f21af514c7a1554d1406b337/d5e13/RPSvMemory.png); One load generator can simulate a few thousand virtual users | [Very good](https://k6.io/blog/static/b4075246f21af514c7a1554d1406b337/d5e13/RPSvMemory.png); One load generator can simulate tens of thousands of virtual users |
| **Memory management** | JVM heap memory must be set | Uses load generator memory natively |
| **Threading model** | 1 Thread: 1 Virtual User; Slower performance, higher resource cost | 1 Goroutine: 1 Virtual User; Faster performance, lower resource cost |
| **Ease of scripting** | GUI-driven, with code blocks | code-driven; VSCode plugin |
| **Test-level thresholds** | No, individual request only | Yes |
| **Script format** | XML | javascript |
| **Collaboration** | Difficult to work on simultaneously; tester-friendly; need the GUI app to edit | Developer-friendly, easy to version; Javascript format promotes collaboration |
| **Maintenance** | Verbose scripts; XML format is difficult to read | More concise scripts; JavaScript is easy to read |
| **Community** | Since 1998; Many third-party tutorials; Extensive documentation; No central community | Since 2017; Extensive documentation; Fewer third-party tutorials; [Official community](https://community.k6.io/) |
| **Plugin support** | Requires plugins for many features, but there are lots of plugins available | Most features are natively supported, but plugin support is new and availability is sparse |
| **Native distributed load generation** | Yes | No (Premium only) |
| **Pre-generated reports** | Default and custom HTML reports; logging via listeners | No built-in pre-generated reports; integration with analytics tools with third-party dashboards |
| **Website** | [jmeter.apache.org](https://jmeter.apache.org/) | [k6.io](https://k6.io) |
| **Source Code** | [Link](https://github.com/apache/jmeter) | [Link](https://github.com/loadimpact/k6)

# Conclusion

The best advice, when attempting to choose a load testing tool, is to do a proof of concept with the most promising candidates. Some features or bugs may prove more or less important when used in an actual testing cycle. However, don't put too much weight on comparisons of the load test _results_ from two different tools - each tool records metrics differently, and it's more meaningful to compare results against previous runs with the same tool. When switching tools, reestablish a baseline in the new tool each time.

Here's a summary that might help you decide between JMeter and k6.

## Both tools do well at:

- Generating protocol-level load on an application server by scripting complex user flows
- Realistic scripting with the use of dynamic think time, test data generation and reuse, and customizable workload models
- Documentation of features and consistency of releases

## Neither tool supports:

- Generating browser-level load and interacting with DOM elements, especially for SPA
- Detailed results analysis (JMeter has pre-generated HTML reports and listeners, but they are far from ideal). Users should expect to integrate results with databases and data visualization software.

## JMeter is best for:

- traditional testing teams
- those looking for a GUI-driven testing tool with tons of third-party tutorials and extensive protocol support
- previous users of commercial tools like LoadRunner and NeoLoad

## k6 is best for:

- collaborative, cross-functional engineering teams where testing spans acrosss multiple roles
- those looking for a simple and lightweight, yet fully-featured load testing tool
- teams looking to integrate testing into existing development workflows and CI/CD pipelines

Load testing scripting tools are by no means the most important consideration for the success of load testing. Knowing _why_ you're testing, what the requirements are, and understanding and communicating results are all arguably more important. The right tool will enable you to address those concerns while providing as little friction as possible. There's no unequivocal "best" tool; there's only the right tool for _your_ project and context.